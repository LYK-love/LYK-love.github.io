<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/white_flower1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/white_flower1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/white_flower1.jpg">
  <link rel="mask-icon" href="/images/white_flower1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lyk-love.cn","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":"enable","trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Outline:  History Hardware File Name Partition BIOS &amp; UEFI File System  介绍了Linux系统的硬件基本知识，更多内容参见我的《OS Introduction》">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Basic">
<meta property="og:url" content="http://lyk-love.cn/2022/02/19/Linux-Basic/index.html">
<meta property="og:site_name" content="LYK-love">
<meta property="og:description" content="Outline:  History Hardware File Name Partition BIOS &amp; UEFI File System  介绍了Linux系统的硬件基本知识，更多内容参见我的《OS Introduction》">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://seec2-lyk.oss-cn-shanghai.aliyuncs.com/Hexo/OS/Linux/%20arch">
<meta property="og:image" content="https://seec2-lyk.oss-cn-shanghai.aliyuncs.com/Hexo/OS/Linux/Primary%20Partition%20Arch.png">
<meta property="og:image" content="https://seec2-lyk.oss-cn-shanghai.aliyuncs.com/Hexo/OS/Linux/Extended%20Partion%20Arch.png">
<meta property="og:image" content="https://seec2-lyk.oss-cn-shanghai.aliyuncs.com/Hexo/OS/Linux/GPT%20Arch">
<meta property="og:image" content="https://seec2-lyk.oss-cn-shanghai.aliyuncs.com/Hexo/OS/OS%20Basic/OS%20Persistence/VFS%20Arch.png">
<meta property="og:image" content="https://seec2-lyk.oss-cn-shanghai.aliyuncs.com/Hexo/OS/OS%20Basic/OS%20Persistence/VFS%20Layer.png">
<meta property="og:image" content="https://seec2-lyk.oss-cn-shanghai.aliyuncs.com/Hexo/OS/OS%20Basic/OS%20Persistence/VFS%20Function%20Call%20workflow.png">
<meta property="og:image" content="https://seec2-lyk.oss-cn-shanghai.aliyuncs.com/Hexo/OS/OS%20Basic/OS%20Persistence/VFS%20example.png">
<meta property="article:published_time" content="2022-02-18T18:47:11.000Z">
<meta property="article:modified_time" content="2023-02-08T07:44:07.947Z">
<meta property="article:author" content="有多远滚多远">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://seec2-lyk.oss-cn-shanghai.aliyuncs.com/Hexo/OS/Linux/%20arch">


<link rel="canonical" href="http://lyk-love.cn/2022/02/19/Linux-Basic/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://lyk-love.cn/2022/02/19/Linux-Basic/","path":"2022/02/19/Linux-Basic/","title":"Linux Basic"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Linux Basic | LYK-love</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?07a572cad308bc3b22d354fca4209fed"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="LYK-love" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">LYK-love</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#History"><span class="nav-text">History</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Feature"><span class="nav-text">Feature</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hardware-File-Name"><span class="nav-text">Hardware File Name</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Partition"><span class="nav-text">Partition</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MBR"><span class="nav-text">MBR</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0%E5%8F%B7%E6%89%87%E5%8C%BA%E7%BB%93%E6%9E%84"><span class="nav-text">0号扇区结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%88%86%E5%8C%BA%EF%BC%88MBR%EF%BC%89"><span class="nav-text">主分区（MBR）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%88%86%E5%8C%BA%E5%92%8C%E9%80%BB%E8%BE%91%E5%88%86%E5%8C%BA"><span class="nav-text">扩展分区和逻辑分区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GPT"><span class="nav-text">GPT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GPT%E5%88%86%E5%8C%BA%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="nav-text">GPT分区表结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BIOS-UEFI"><span class="nav-text">BIOS &amp; UEFI</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BIOS"><span class="nav-text">BIOS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UEFI"><span class="nav-text">UEFI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ESP"><span class="nav-text">ESP</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#boot-loader"><span class="nav-text">boot loader</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E7%BD%AE"><span class="nav-text">位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD"><span class="nav-text">功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9Aboot-loader"><span class="nav-text">多boot loader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E7%B3%BB%E7%BB%9F"><span class="nav-text">多重系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LILO"><span class="nav-text">LILO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GRUB"><span class="nav-text">GRUB</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#kernel"><span class="nav-text">kernel</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-text">模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96"><span class="nav-text">模块依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#depmod"><span class="nav-text">depmod</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E6%93%8D%E4%BD%9C"><span class="nav-text">模块操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%A8%A1%E5%9D%97"><span class="nav-text">查看模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD-%E5%88%A0%E9%99%A4%E6%A8%A1%E5%9D%97"><span class="nav-text">加载&#x2F;删除模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E4%B8%8E%E6%99%AE%E9%80%9A%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">模块与普通程序的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97example"><span class="nav-text">模块example</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E4%BC%A0%E5%8F%82"><span class="nav-text">模块传参</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%87%BA%E7%AC%A6%E5%8F%B7"><span class="nav-text">模块导出符号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E9%80%9A%E4%BF%A1example"><span class="nav-text">模块通信example</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91"><span class="nav-text">模块编译</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Initial-RAM-Filesystem"><span class="nav-text">Initial RAM Filesystem</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux%E8%AE%BE%E5%A4%87"><span class="nav-text">Linux设备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-text">设备驱动的加载过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mknod"><span class="nav-text">mknod</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="nav-text">设备号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="nav-text">申请和释放设备号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cdev%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">cdev结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E6%B3%A8%E5%86%8C"><span class="nav-text">设备注册</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#proc"><span class="nav-text">&#x2F;proc</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#OS%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">OS启动过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#VFS"><span class="nav-text">VFS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B1%82"><span class="nav-text">分层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D%E7%A4%BA%E4%BE%8B"><span class="nav-text">接口适配示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E8%AE%BE%E5%A4%87-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A4%BA%E4%BE%8B"><span class="nav-text">跨设备&#x2F;文件系统示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VFS%E6%94%AF%E6%8C%81%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">VFS支持的系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VFS%E6%94%AF%E6%8C%81%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">VFS支持的文件系统</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-text">Linux目录结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="nav-text">包管理工具</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#File-System"><span class="nav-text">File System</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Windows"><span class="nav-text">Windows</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux"><span class="nav-text">Linux</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="有多远滚多远"
      src="/images/white_flower1.jpg">
  <p class="site-author-name" itemprop="name">有多远滚多远</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">213</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LYK-love" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LYK-love" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:191820133@smail.nju.edu.cn" title="E-Mail → mailto:191820133@smail.nju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://lyk-love.cn/2022/02/19/Linux-Basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/white_flower1.jpg">
      <meta itemprop="name" content="有多远滚多远">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYK-love">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Linux Basic | LYK-love">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux Basic
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-18 18:47:11" itemprop="dateCreated datePublished" datetime="2022-02-18T18:47:11Z">2022-02-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-08 07:44:07" itemprop="dateModified" datetime="2023-02-08T07:44:07Z">2023-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Outline:</p>
<ul>
<li>History</li>
<li>Hardware File Name</li>
<li>Partition</li>
<li>BIOS &amp; UEFI</li>
<li>File System</li>
</ul>
<p>介绍了Linux系统的硬件基本知识，更多内容参见我的《OS Introduction》</p>
<span id="more"></span>
<h1 id="History"><a class="header-anchor" href="#History"></a>History</h1>
<ul>
<li>Unix 的前身是由贝尔实验室(Bell lab.)的 Ken Thompson 利用汇编语言写成的, 后来在 1971-1973 年间由</li>
<li>Dennis Ritchie 以 C 程序语言进行改写,才称为 Unix。</li>
<li>1977 年由 Bill Joy 释出 BSD (Berkeley Software Distribution),这些称为 Unix-like 的操作系统。</li>
<li>1984 年由 Andrew Tanenbaum 开始制作 Minix 操作系统,该系统可以提供原始码以及软件;</li>
<li>1984 年由 Richard Stallman 提倡 GNU 计划,倡导自由软件(Free software), 强调其软件可以『自由的取得、</li>
<li>复制、修改与再发行』 ,并规范出 GPL 授权模式, 任何 GPL(General Public License)软件均不可单纯仅贩卖<br>
其软件,也不可修改软件授权。</li>
<li>1991 年由芬兰人 Linus Torvalds 开发出 Linux 操作系统。简而言之, Linux 成功的地方主要在于:Minix(Unix),<br>
GNU, Internet, POSIX 及虚拟团队的产生。符合 Open source 理念的授权相当多,比较知名的如 Apache / BSD / GPL / MIT 等。</li>
</ul>
<h2 id="Feature"><a class="header-anchor" href="#Feature"></a>Feature</h2>
<ul>
<li>Linux是藉由 Minix 操作系统开发的,， 属于 Unix like ,没有版权纠纷</li>
<li>Linux 支持 POSIX ,因此很多 Unix 上的程序可以直接在 Linux 上运作</li>
</ul>
<h1 id="Hardware-File-Name"><a class="header-anchor" href="#Hardware-File-Name"></a>Hardware File Name</h1>
<p>Linux中一切皆文件，磁盘文件名形如<code>/dev/sd[a-z]</code>，虚拟机可能会使用 <code>/dev/vd[a-z]</code></p>
<h1 id="Partition"><a class="header-anchor" href="#Partition"></a>Partition</h1>
<p>分区就是对分区表进行配置，通常分区是以Cylinder为单位的『连续』磁盘空间。 现代也可以用sector为单位</p>
<p>分区表有两种格式： MBR, GPT</p>
<h2 id="MBR"><a class="header-anchor" href="#MBR"></a>MBR</h2>
<p>MBR磁盘分区是一种使用最为广泛的分区结构，它也被称为DOS分区结构，但它并不仅仅应用于Windows系统平台，也应用于Linux，基于X86的UNIX等系统平台。它位于磁盘的0号扇区（一扇区等于512字节），是一个重要的扇区（简称MBR扇区）</p>
<p>主要分区与延伸分区最多可以有四个(硬盘的限制)<br>
延伸分区最多只能有一个(操作系统的限制)<br>
逻辑分区是由延伸分区持续切割出来的分区槽;<br>
能够被格式化后,作为数据存取的分区槽为主要分区与逻辑分区。延伸分区无法格式化;<br>
逻辑分区的数量依操作系统而不同,在 Linux 系统中 SATA 硬盘已经可以突破 63 个以上的分区限制;</p>
<h3 id="0号扇区结构"><a class="header-anchor" href="#0号扇区结构"></a>0号扇区结构</h3>
<p>在MBR分区表中，一个分区最大的容量为2T，且每个分区的起始柱面必须在这个硬盘的前2T内。你有一个3T的硬盘，根据要求你至少要把它划分为2个分区，且最后一个分区的起始扇区要位于硬盘的前2T空间内。如果硬盘太大则必须改用GPT</p>
<p>标准MBR结构：</p>
<p><img data-src="https://seec2-lyk.oss-cn-shanghai.aliyuncs.com/Hexo/OS/Linux/%20arch" alt="MBR Arch"></p>
<p>MBR扇区(0号扇区)由四部分组成：</p>
<ul>
<li>
<p>主引导记录（MBR）：一段引导代码，占MBR分区的前446字节，负责整个系统启动。如果引导代码被破坏，系统将无法启动。</p>
</li>
<li>
<p>Windows磁盘签名：占引导代码后面的4字节，是Windows初始化磁盘写入的磁盘标签，如果此标签被破坏，则系统会提示“初始化磁盘”。</p>
</li>
<li>
<p>MBR分区表：4个16字节的“磁盘分区表”(DPT), 可以分出四个主分区</p>
<ul>
<li>所谓的『分区』就是配置分区表</li>
<li>可以将一个主分区作为<strong>扩展分区</strong>， 扩展分区可以继续分出<strong>逻辑分区</strong></li>
</ul>
</li>
<li>
<p>MBR结束标志：占MBR扇区最后2个字节，一直为“55 AA”， 检验主引导记录是否有效</p>
</li>
</ul>
<h3 id="主分区（MBR）"><a class="header-anchor" href="#主分区（MBR）"></a>主分区（MBR）</h3>
<p>分区表示例，假设该硬盘的挂载文件名为<code>/dev/sda </code>， 分区的挂载文件名为<code>[硬盘文件名][分区id]</code></p>
<p><img data-src="https://seec2-lyk.oss-cn-shanghai.aliyuncs.com/Hexo/OS/Linux/Primary%20Partition%20Arch.png" alt="Primary Partition Arch"></p>
<p>分区的文件名为硬盘名 + 后缀</p>
<ul>
<li>
<p>例如，上述四个主分区的挂载文件名为：</p>
<p>P1:/dev/sda1<br>
P2:/dev/sda2<br>
P3:/dev/sda3<br>
P4:/dev/sda4</p>
</li>
</ul>
<p>一个硬盘，只能有4个主分区，</p>
<p>（恢复分区也占一个分区）</p>
<p>（微软引导占一个）</p>
<p>（微软OS占一个C盘分区）</p>
<p>（剩下的一个主分区可以做扩展分区，做出最多4个逻辑分区）</p>
<p>在这样的情况下，是没法双系统的，因为4个主分区已经用完了</p>
<ul>
<li>MBR用32位寻址，每个bit代表512字节，因此只能支持2T硬盘</li>
</ul>
<h3 id="扩展分区和逻辑分区"><a class="header-anchor" href="#扩展分区和逻辑分区"></a>扩展分区和逻辑分区</h3>
<p>示例： 这里有两个主分区P1,P2, P2被用作扩展分区</p>
<p><img data-src="https://seec2-lyk.oss-cn-shanghai.aliyuncs.com/Hexo/OS/Linux/Extended%20Partion%20Arch.png" alt="Extended Partion Arch"></p>
<ul>
<li>
<p>主分区最多有4个，为了获得更多的分区，可以将一个主分区变成<strong>扩展分区</strong>，在扩展分区内进行<strong>逻辑分区</strong></p>
</li>
<li>
<p>利用扩展分区的第一个扇区，可以分出逻辑扇区， 逻辑分区的分区信息存放在<strong>扩展引导记录</strong>（<strong>EBR</strong>）中</p>
<ul>
<li>这里的EBR仅仅指EBR分区， 包括分区表和结束标志“55 AA”，<u>没有引导代码</u></li>
<li>逻辑分区位于扩展分区内，其磁柱范围也当然在扩展分区的磁柱范围内，上例中就是101-401</li>
</ul>
</li>
<li>
<p><strong>最多有1个扩展分区</strong>（OS规定）</p>
</li>
<li>
<p>[分区id]的前4都保留给主分区和扩展分区。 因此逻辑分区的分区id从5开始。上例中各分区文件名如下：</p>
<blockquote>
<p>P1:/dev/sda1<br>
P2:/dev/sda2<br>
L1:/dev/sda5<br>
L2:/dev/sda6<br>
L3:/dev/sda7<br>
L4:/dev/sda8<br>
L5:/dev/sda9</p>
</blockquote>
</li>
<li>
<p>逻辑分区的数量依操作系统而不同, 在 Linux 系统中 SATA 硬盘已经可以突破 63 个以上的分区限制</p>
</li>
</ul>
<h2 id="GPT"><a class="header-anchor" href="#GPT"></a>GPT</h2>
<p>全局唯一标识分区表（GUID Partition Table）</p>
<p>可以有很多主分区，也就不需要扩展分区和逻辑分区了</p>
<p>最大硬盘容量9.4ZB</p>
<p>缺点是浪费更多的磁盘空间</p>
<h2 id="GPT分区表结构"><a class="header-anchor" href="#GPT分区表结构"></a>GPT分区表结构</h2>
<p>简言之，前512字节保留，用于MBR。后512字节用于GPT Header，然后是分区表， 分区表在磁盘尾部又会备份一遍</p>
<p><img data-src="https://seec2-lyk.oss-cn-shanghai.aliyuncs.com/Hexo/OS/Linux/GPT%20Arch" alt="GPT Arch"></p>
<ul>
<li>
<p>LBA0: MBR相容区块</p>
<p>前512字节（0号扇区）有个保护MBR（用于防止不识别GPT的硬盘工具错误识别并破坏硬盘中的数据），这个MBR中只有一个类型为0xEE的分区，以此来表示这块硬盘使用GPT分区表。不能识别GPT硬盘的操作系统通常会识别出一个未知类型的分区，并且拒绝对硬盘进行操作；能够识别GPT分区表的操作系统会检查保护MBR中的分区表，如果分区类型不是0xEE或者MBR分区表中有多个项，也会拒绝对硬盘进行操作</p>
</li>
<li>
<p>LBA1： GPT表头记录</p>
<p>GPT头位于GPT磁盘的第二个磁盘，也就是1号扇区，该扇区是在创建GPT磁盘时生成，GPT头会定义分区表的起始位置，分区表的结束位置、每个分区表项的大小、分区表项的个数及分区表的校验和等信息。</p>
</li>
<li>
<p>LBA2～33： 实际记录分区信息处</p>
<p>分区表位于GPT磁盘的2-33号磁盘，一共占用32个扇区，能够容纳128个分区表项。每个分区表项大小为128字节。因为每个分区表项管理一共分区，所以Windows系统允许GPT磁盘创建128个分区</p>
</li>
<li>
<p>LBA34到-34： 分区区域</p>
<p>GPT分区区域就是用户使用的分区，也是用户进行数据存储的区域。分区区域的起始地址和结束地址由GPT头定义。</p>
</li>
<li>
<p>LBA-33~-2: 分区表备份</p>
</li>
<li>
<p>LBA-1： GPT头备份</p>
<p>GPT头有一个备份，放在GPT磁盘的最后一个扇区，但这个GPT头备份并非完全GPT头备份，某些参数有些不一样。复制的时候根据实际情况更改一下即可。</p>
</li>
</ul>
<h1 id="BIOS-UEFI"><a class="header-anchor" href="#BIOS-UEFI"></a>BIOS &amp; UEFI</h1>
<p>计算机启动时，首先加载硬件驱动程序， 硬件驱动程序有：</p>
<ul>
<li>BIOS：对应分区格式MBR， 读取MBR分区
<ul>
<li>BIOS模式又称为<code>Legacy</code></li>
</ul>
</li>
<li>UEFI： 对应分区格式GPT， 读取EFI分区</li>
</ul>
<h2 id="BIOS"><a class="header-anchor" href="#BIOS"></a>BIOS</h2>
<p>BIOS是写入到主板上的一个程序。主板上还有硬件CMOS， 是记录各项硬件参数且嵌入在主板上的储存器；</p>
<ul>
<li>BIOS是开机时,计算机会执行的第一个程序</li>
</ul>
<h2 id="UEFI"><a class="header-anchor" href="#UEFI"></a>UEFI</h2>
<p>UEFI (Unified Extensible Firmware Interface) 是BIOS的进化版，也称为UEFI BIOS</p>
<ul>
<li>
<p>UEFI对应分区格式GPT, 启动后读取EFI分区（EFI system partition， aka <strong>ESP</strong>）</p>
<ul>
<li>EFI是UEFI的1.0版本</li>
</ul>
</li>
<li>
<p>UEFI用C编程，BIOS用汇编编程。 因此UEFI非常强大</p>
</li>
</ul>
<p>BIOS缺点：</p>
<ul>
<li>BIOS不知道GPT,还需要GPT 提供兼容模式才能够读写这个磁盘装置</li>
<li>BIOS仅为 16 位的程序，功能太简单</li>
</ul>
<p>UEFI 可以直接取得 GPT 的分区表,但保险起见，你最好依旧拥有BIOS boot的分区槽支持, 同时,为了与 windows 兼容,并且提供其他第三方厂商所使用的 UEFI 应用程序储存的空间,你必须要格式化一个 vfat 的文件系统, 大约提供 512MB 到 1G 左右的容量,以让其他 UEFI 执行较为方便</p>
<h3 id="ESP"><a class="header-anchor" href="#ESP"></a>ESP</h3>
<p>EFI系统分区（EFI system partition）:GPT硬盘分区模式中的系统启动分区</p>
<ul>
<li>FAT16或FAT32格式的物理分区，</li>
<li>其分区标识是EF (十六进制) 而非常规的0E或0C。</li>
<li>该分区在Windows操作系统下一般是不可见的。</li>
<li>ESP分区是一个独立于操作系统之外的分区，操作系统被引导后就不再依赖它。分区内存放引导管理程序、驱动程序、系统维护工具等。支持 EFI 模式的电脑需要从ESP启动系统，EFI固件可从ESP加载EFI启动程序和应用程序</li>
</ul>
<h1 id="boot-loader"><a class="header-anchor" href="#boot-loader"></a>boot loader</h1>
<p>boot loader用于加载OS内核， 由于每种OS的文件系统不一致，因此每种OS都有自己的boot loader</p>
<p>boot loader位于MBR中，最大只有446字节</p>
<p>常用的boot loader是grub（version2）</p>
<h2 id="位置"><a class="header-anchor" href="#位置"></a>位置</h2>
<p>每个文件系统都会保留一块启动扇区（boot sector）来安装该OS的boot loader， <strong>即OS都会默认安装一份boot loader到自己的文件系统中</strong>（位于根目录所在的文件系统的boot sector）</p>
<p>LInux安装时，可以选择将boot loader安装到MBR，如果安装了，则MBR和boot sector都会保留一份boot loader</p>
<p>Windows安装时默认会将boot loader也安装到MBR</p>
<h2 id="功能"><a class="header-anchor" href="#功能"></a>功能</h2>
<p>boot loader主要功能：</p>
<ul>
<li>加载内核文件：直接指向可开机的程序区段来启动OS</li>
<li>提供选项：用户可以选择不同启动选项</li>
<li>转交其他loader： 将启动管理功能<strong>转交给其他loader</strong></li>
</ul>
<p>选项功能使得我们可以<strong>选择不同的内核来启动</strong>，而转交功能使我们可以<strong>加载其他地方（也就是其他boot sector）的loader</strong></p>
<h2 id="多boot-loader"><a class="header-anchor" href="#多boot-loader"></a>多boot loader</h2>
<p>![image-20220504012023432](/Users/lyk/Library/Application Support/typora-user-images/image-20220504012023432.png)</p>
<p>如上图所示，我的 MBR 使用 Linux 的 grub2 这个开机管理程序，并且里面假设已经有了三个菜 单， 第一个菜单可以直接指向 Linux 的核心文件并且直接载入核心来开机;第二个菜单可以将开机管理程 控权交给 Windows 来管理，此时 Windows 的 loader 会接管开机流程，这个时候他就能够启动 windows 了。 第三个菜单则是使用 Linux 在 boot sector 内的开机管理程序，此时进入另一个grub</p>
<h2 id="多重系统"><a class="header-anchor" href="#多重系统"></a>多重系统</h2>
<p><strong>windows的loader不具有转交功能</strong>，因此不能使用windows的loader启动linux的loader，也就是说，装多系统的时候，需要先装windows，再装linux</p>
<ul>
<li>前文已提到，windows的boot loader会自动覆盖MBR扇区，那么如果后安装windows，启动扇区就被覆盖为windows的loader，而它无法转交给其他loader，即无法支持多系统</li>
</ul>
<p>A boot loader loads and starts the Linux kernel</p>
<ul>
<li>Can pass boot parameters to the Linux kernel, such as <strong>device information</strong></li>
<li>Can optionally load an Initial Root Disk</li>
<li>Can boot other operating systems as well </li>
</ul>
<p>Common Boot loaders:</p>
<ul>
<li>LILO: Linux Loader</li>
<li>GRUB: Grand Unified Boot Loader </li>
</ul>
<p>Generally configured in <code>/dev/sda</code>, unless other boot loader is usd（存疑）</p>
<h2 id="LILO"><a class="header-anchor" href="#LILO"></a>LILO</h2>
<p>LILO:</p>
<ul>
<li>
<p>A Program that configures the MBR according to the configuration file.</p>
<p>Must be run as root with the lilo command.</p>
</li>
</ul>
<p>lilo command Syntax:</p>
<ul>
<li><code>lilo [-v] [-v] [-C config-file] [-t] </code></li>
<li>Configuration file: <code>/etc/lilo.conf</code></li>
</ul>
<h2 id="GRUB"><a class="header-anchor" href="#GRUB"></a>GRUB</h2>
<p>目前都是grub2</p>
<p>grub是主流的boot loader程序，由于MBR扇区太小，最大才446字节，因此grub的配置文件没有放在MBR，而是放在<code>/boot/grub</code></p>
<p>详见《GRUB》</p>
<p>GRUB</p>
<ul>
<li>Program stored in MBR (first stage) and in /boot/grub (1.5th and second stage)</li>
<li>Understand file system structure; no need to activate a configuration as with LILO </li>
<li>Configuration file <code>/boot/grub/grub.conf </code></li>
<li>Installed in MBR with <code>grub-install</code></li>
</ul>
<h1 id="kernel"><a class="header-anchor" href="#kernel"></a>kernel</h1>
<p>内核文件:<code>/boot/vmlinuz</code></p>
<p>内核源代码：<code>/usr/src/linux</code></p>
<h1 id="模块"><a class="header-anchor" href="#模块"></a>模块</h1>
<p>内核模块：<code>/lib/modules/$(uname -r)/kernel</code></p>
<p>模块文件都以<code>.ko</code>为后缀</p>
<p>Linux发行版一般都会将非必要的且可以编译为模块的内核功能编译成模块， 比如各种设备驱动程序.</p>
<p>linux内核可以动态加载内核模块，内核接管系统后，会尝试检测硬件并<strong>挂载根目录</strong>，来取得内核模块，这样才能利用它们提供的设备加载功能</p>
<ul>
<li>不能把<code>/lib</code>和<code>/</code>放在不同的硬盘分区</li>
<li>由于担心影响到磁盘内的文件系统，启动过程中根目录一般以只读的形式挂载</li>
<li>因此，如果遇到OS不支持的新硬件，要么重新编译内核，并加入该硬件的驱动程序源码； 要么将该硬件的驱动程序编译成模块，在启动时加载该模块</li>
</ul>
<h2 id="模块依赖"><a class="header-anchor" href="#模块依赖"></a>模块依赖</h2>
<p>一个模块A引用另一个模块B所导出的符号，则加载模块A之前必须先加载模块B，这称为模块依赖</p>
<p>模块依赖关系存放在<code>/lib/modules/$(uname -r)/modules.dep</code>， 要生成该文件，需要用<code>depmod</code></p>
<h3 id="depmod"><a class="header-anchor" href="#depmod"></a>depmod</h3>
<p><code>depmod [-adeisvV][-m &lt;文件&gt;][--help][模块名称]</code></p>
<ul>
<li>不加任何参数：分析当前内核的模块依赖(模块位于<code>/lib/modules/$(uname -r)/kernel</code>)，并重新写入<code>modules.dep</code></li>
<li><code>-A</code>:  查找比 <code>modues.dep</code> 内还要新的模块，找到了才会更新<code>modules.dep</code></li>
</ul>
<ul>
<li><code>-a</code>: 检查所有模块，如果命令中没有文件名称，这个选项默认是开启的</li>
<li><code>-e</code>: 显示出目前已加载的不可执行的模块</li>
<li><code>-n</code>: 将结果 <code>modules.dep</code> 和各种映射文件输出到标准输出( <code>stdout</code> )，而不是写到<code>modules.dep</code></li>
</ul>
<h2 id="模块操作"><a class="header-anchor" href="#模块操作"></a>模块操作</h2>
<h3 id="查看模块"><a class="header-anchor" href="#查看模块"></a>查看模块</h3>
<p>列出模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; lsmod</span><br><span class="line">Module                  Size  Used by</span><br><span class="line">ip6table_filter        16384  0</span><br><span class="line">ip6_tables             32768  1 ip6table_filter</span><br><span class="line">xt_recent              24576  0</span><br><span class="line">binfmt_misc            24576  1</span><br></pre></td></tr></table></figure>
<p>显示内容有：</p>
<ul>
<li>模块名称</li>
<li>模块大小</li>
<li>依赖该模块的模块</li>
</ul>
<p>查看模块信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modinfo kernel_module</span><br></pre></td></tr></table></figure>
<ul>
<li>参数可以是模块名，也可以是模块文件名</li>
</ul>
<h3 id="加载-删除模块"><a class="header-anchor" href="#加载-删除模块"></a>加载/删除模块</h3>
<p>加载/删除模块推荐使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modprobe [模块名]</span><br></pre></td></tr></table></figure>
<ul>
<li>查找<code>modules.dep</code>的内容，得到模块依赖性，并加载模块</li>
</ul>
<p>选项有：</p>
<ul>
<li>
<p>默认是加载模块</p>
</li>
<li>
<p><code>-c</code>： 列出目前系统所有的模块（信息更多）</p>
</li>
<li>
<p><code>-f</code>: 强制加载该模块</p>
</li>
<li>
<p><code>-r</code>: 删除模块</p>
</li>
</ul>
<p>普通方法：不会分析依赖树，因此很比较麻烦</p>
<ul>
<li>加载模块：<code>insmod [模块文件名]</code></li>
<li>删除模块: <code>rmmod [模块名/模块文件名]</code></li>
</ul>
<h2 id="模块与普通程序的区别"><a class="header-anchor" href="#模块与普通程序的区别"></a>模块与普通程序的区别</h2>
<table>
<thead>
<tr>
<th></th>
<th>C程序</th>
<th>Linux模块</th>
</tr>
</thead>
<tbody>
<tr>
<td>所在空间</td>
<td>user mod</td>
<td>kernel mode</td>
</tr>
<tr>
<td>入口</td>
<td>main()</td>
<td>module_init()指定;</td>
</tr>
<tr>
<td>出口</td>
<td>无</td>
<td>module_exit()指定;</td>
</tr>
<tr>
<td>运行方式</td>
<td>直接运行</td>
<td>inmod</td>
</tr>
<tr>
<td>调试方式</td>
<td>gdb</td>
<td>kdbug, kdb, kgdb等</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>注意点：</p>
<ul>
<li>不能使用C库来开发模块</li>
<li>没有内存保护机制</li>
<li>小内核栈</li>
<li>要考虑并发</li>
</ul>
<h2 id="模块example"><a class="header-anchor" href="#模块example"></a>模块example</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye world\n&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init); </span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>static int __init hello_init(void)</code></li>
<li><code>static void __exit hello_exit(void)</code>
<ul>
<li>Static：声明该函数作用域为当前文件，因为这种函数在特定文件之外没有其它意义</li>
<li><code>__init</code>: 标记该函数只在初始化期间使用。模块装载后，将 该函数占用的内存空间释放</li>
<li><code>–  __exit</code>: 标记该代码仅用于模块卸载</li>
</ul>
</li>
<li>Init/exit
<ul>
<li>宏: <code>module_init</code>/<code>module_exit</code></li>
<li>声明模块初始化及清除函数所在的位置</li>
<li>装载和卸载模块时，内核可以自动找到相应的函数
<ul>
<li><code>module_init(hello_init); </code></li>
<li><code>module_exit(hello_exit);</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="模块传参"><a class="header-anchor" href="#模块传参"></a>模块传参</h2>
<p>有些模块需要传递一些参数</p>
<ul>
<li>
<p>参数在模块加载时传递</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nsmod hello.ko test=2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在模块代码中， 需要使用<code>module_param</code>宏来声明:  <code>module_param(变量名称，类型, 访问许可掩码)</code></p>
</li>
<li>
<p>支持的参数类型<br>
Byte, short, ushort, int, uint, long, ulong, bool, charp Array (module_param_array(name, type, nump, perm))</p>
</li>
</ul>
<p>example</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> test; </span><br><span class="line">module_param(test, <span class="type">int</span>, <span class="number">0644</span>);<span class="comment">//参数声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO “Hello world test=%d \n” , test);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Goodbye world\n&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>); </span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Test&quot;</span>); </span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;xxx&quot;</span>); </span><br><span class="line"></span><br><span class="line">module_init(hello_init); </span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure>
<h2 id="模块导出符号"><a class="header-anchor" href="#模块导出符号"></a>模块导出符号</h2>
<p>如果一个模块需要向其他模块导出符号(方法或全局变量)，需要使用:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXPORT_SYMBOL(name); </span><br><span class="line">EXPORT_SYMBOL_GPL(name);</span><br></pre></td></tr></table></figure>
<ul>
<li>符号必须在模块文件的全局部分导出，不能在函数部分导出。 更多信息可参考 &lt;linux/module.h&gt;文件</li>
</ul>
<p>• Modules仅可以使用由Kernel或者其他Modules导出的符号, 不能使用Libc</p>
<p>• <code>/proc/kallsyms </code>: 保存了所有导出的符号</p>
<h2 id="模块通信example"><a class="header-anchor" href="#模块通信example"></a>模块通信example</h2>
<p>本实例通过两个模块来介绍模块之间的通信。 模块add_sub提供了两个导出函数add_integer() 和sub_integer()，分别完成两个数字的加法和减 法。模块test用来调用模块add_sub提供的两个 方法，完成加法或者减法操作。</p>
<ul>
<li>1.add_sub模块</li>
<li>2.test模块 • 3.编译模块</li>
</ul>
<p><code>add_sub.h</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ADD_SUB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ADD_SUB_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">add_integer</span><span class="params">(<span class="type">long</span> a,longb)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">sub_integer</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>add_sub：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;l inux /module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add_sub.h&quot;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">add_integer</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> sub <span class="title function_">integer</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT <span class="title function_">SYMBOL</span><span class="params">(add_integer)</span> ;</span><br><span class="line">EXPORT <span class="title function_">SYMBOL</span><span class="params">(sub_integer)</span> ;</span><br><span class="line">MODULELICENSE (<span class="string">&quot;Dual BSD/GPL&quot;</span>) ;</span><br></pre></td></tr></table></figure>
<h2 id="模块编译"><a class="header-anchor" href="#模块编译"></a>模块编译</h2>
<p>Makefile:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-m := hello.o</span><br><span class="line">all:</span><br><span class="line">	make -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) modules</span><br><span class="line">clean:</span><br><span class="line">	make -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) clean</span><br></pre></td></tr></table></figure>
<p>Module includes more files</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-m:=hello.o</span><br><span class="line"></span><br><span class="line">hello-objs := a.o b.o</span><br></pre></td></tr></table></figure>
<h1 id="Initial-RAM-Filesystem"><a class="header-anchor" href="#Initial-RAM-Filesystem"></a>Initial RAM Filesystem</h1>
<p>由于内核启动时需要挂载根目录，来加载其中的设备驱动程序。 假设根目录所在的设备为SATA硬盘，linux需要SATA的驱动才能读取SATA盘并挂载根目录，可是取得SATA的驱动又需要先读取SATA盘，挂载根目录。 为了解决这个问腿，boot loader不仅会读取内核文件， 还会读取一个虚拟文件系统文件(<code>/boot/initramfs.img</code>， 名称在不同的OS中可能不同 )，该文件会被读取到内存中并解压缩成一个根目录，并提供一个程序，通过该程序来加载启动过程中所需要的内核模块（比如上文提到的SATA驱动），然后initramfs会被释放，并挂载实际的根目录文件系统，接着内核会调用systemd来开始后续的正常启动流程</p>
<ul>
<li>当然你可以将必须的驱动直接编译到内核中，也就避免了上述的矛盾，不需要initramfs了</li>
</ul>
<p>initrd:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkinitrd /boot/initrd.img $(uname  r)</span><br></pre></td></tr></table></figure>
<p>initramfs:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkinitramfs  o /boot/initrd.img $(uname -r)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">update-initramfs -u</span><br></pre></td></tr></table></figure>
<h1 id="Linux设备"><a class="header-anchor" href="#Linux设备"></a>Linux设备</h1>
<p>Linux系统将设备分为3种类型，对应三种驱动</p>
<ul>
<li>字符设备 -- Character Driver</li>
<li>块设备 -- Block Driver</li>
<li>网络接口设备 -- Network Driver</li>
</ul>
<h2 id="设备驱动的加载过程"><a class="header-anchor" href="#设备驱动的加载过程"></a>设备驱动的加载过程</h2>
<p>以字符设备驱动为例，它的加载过程是：</p>
<ol>
<li>申请设备号：包括主设备号码和次设备号</li>
<li>定义文件操作结构体<code>file_operations</code></li>
<li>创建并初始化定义结构体cdev
<ol>
<li>cdev结构体描述字符设备</li>
<li>该结构体是所有字符设备的抽象，其包含了大量字符设备所共有的特性。</li>
</ol>
</li>
<li>将cdev注册到系统，并和对应的设备号绑定</li>
<li>在/dev文件系统中用mknod创建设备文件，并将该文件绑定到设备号上
<ol>
<li>设定设备号:<code>device=scull</code></li>
<li>定义主设备号:<code>major=15</code></li>
<li>用户可以通过访问<code>/dev/scull</code>来访问当前的驱动设备</li>
</ol>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mknod /dev/$&#123;device&#125;0 c $major 0</span><br></pre></td></tr></table></figure>
<h2 id="mknod"><a class="header-anchor" href="#mknod"></a>mknod</h2>
<p>mknod: Create block or character device special files.</p>
<ul>
<li>
<p>Create a block device:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mknod path/to/device_file b major_device_number minor_device_number</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Create a character device:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mknod path/to/device_file c major_device_number minor_device_number</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Create a FIFO (queue) device:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mknod path/to/device_file p</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Create a device file with default SELinux security context:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mknod -Z path/to/device_file type major_device_number minor_device_number</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mknod /dev/zero15 c 1 5</span><br></pre></td></tr></table></figure>
<p>意思是创建一个字符型设备文件<code>/dev/zero15 </code>, 设备号为：主设备号5， 副设备号1</p>
<h2 id="设备号"><a class="header-anchor" href="#设备号"></a>设备号</h2>
<p>一个字符设备或者块设备都有一个主设备号和次设备号</p>
<p>• 主设备号和次设备号统称为设备号。 主设备号用来表示一个特定的<strong>驱动程序</strong></p>
<p>• 次设备号用来表示使用该驱动程序的各<strong>设备</strong></p>
<h3 id="申请和释放设备号"><a class="header-anchor" href="#申请和释放设备号"></a>申请和释放设备号</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span> first, <span class="type">unsigned</span> <span class="type">int</span> count, <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> <span class="type">int</span> firstminor, <span class="type">unsigned</span> <span class="type">int</span> count, <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_chrdev_region</span><span class="params">(<span class="type">dev_t</span> first, <span class="type">unsigned</span> <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="cdev结构体"><a class="header-anchor" href="#cdev结构体"></a>cdev结构体</h2>
<p>在linux内核中使用cdev结构体来描述 字符设备。该结构体是所有字符设备的抽象，其包含了大量字符设备所共有的特性</p>
<p>cdev结构体的初始化:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">my_cdev</span> =</span> cdev_alloc();</span><br><span class="line">my_cdev-&gt;ops = &amp;my_fops;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="keyword">struct</span> file_operations *fops)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scull_dev</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">scull</span> <span class="title">qset</span> *<span class="title">data</span>;</span> <span class="comment">/* Pointer to first quantum set */</span></span><br><span class="line">   <span class="type">int</span> quantum; <span class="comment">/* the current quantum size */</span></span><br><span class="line">   <span class="type">int</span> qset; <span class="comment">/* the current array size */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> size; <span class="comment">/* amount of data stored here */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> access_ key; <span class="comment">/* used by sculluid and scullpriv */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span> <span class="comment">/* mutual exclus ion semaphore */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">/* Char device structure*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="设备注册"><a class="header-anchor" href="#设备注册"></a>设备注册</h3>
<ul>
<li>
<p>将设备注册到系统中:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *dev, <span class="type">dev_t</span> num, <span class="type">unsigned</span> <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>释放一个已经注册的设备:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_del</span><span class="params">(<span class="keyword">struct</span> cdev *dev)</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="proc"><a class="header-anchor" href="#proc"></a>/proc</h1>
<ul>
<li>/proc文件系统是内核模块和系统交互的两种主要方式之一</li>
<li>/proc文件系统是一个伪文件系统。</li>
<li>通过/proc，可以用标准Unix系统调用(比如open()、 read()、write()、 ioctl()等等)<strong>访问进程地址空间</strong></li>
<li>用户和应用程序可以通过/proc得到系统的信息，并可以改变内核的某些参数</li>
<li>可以用于调试程序或者获取指定进程状态</li>
</ul>
<ul>
<li>create_proc_entry(): 创建一个文件</li>
<li>proc_symlink();: 创建符号链接</li>
<li>proc_mknod(): 创建设备文件</li>
<li>proc_mkdir(): 创建目录</li>
<li>remove_proc_entry(): 删除文件或目录</li>
</ul>
<h1 id="OS启动过程"><a class="header-anchor" href="#OS启动过程"></a>OS启动过程</h1>
<p>从开机到启动OS的过程为：</p>
<ol>
<li>
<p>BIOS:开机时主动加载，BIOS会通过加载CMOS中的信息，得到主机的硬件配置信息（包括启动设备的查找顺序、硬盘的大小与类型、系统时间...）; 得到这些信息后，BIOS会进行启动自我检测（ Power-on Self Test, POST ）, 然后开始执行硬件的初始化、设置PnP设备，再<strong>定义出可启动的设备顺序</strong>，接下来开始读取启动设备的MBR，其中安装了boot loader程序</p>
<ul>
<li>这里的MBR泛指启动扇区，GPT也有MBR扇区</li>
</ul>
</li>
<li>
<p>MBR： BIOS读取MBR，<strong>注意，每块硬盘的第一个扇区都是MBR扇区，所以如果有多个硬盘，也就是多个启动设备的话，读取的应该是“第一个启动设备的MBR”</strong>（ 之前已经定义好了启动设备的顺序）</p>
</li>
<li>
<p>boot loader： BIOS加载MBR的boot loader程序，该程序用于读取kernel，将kernel解压缩到内存中; boot loader同时还会读取<code>initramfs</code>来加载一些必要的驱动，并挂载根目录</p>
<ul>
<li>BIOS通过硬件的INT13中断来读取MBR，因此，只要BIOS能检测到硬盘，就一定能读取MBR（其中的内容就是boot loader）</li>
<li>内核驱动位于根目录的<code>/lib/modules</code>，则内核需要先挂载根目录才能取得这些驱动，但是内核没有驱动又无法读取硬盘、挂载根目录。 因此boot loader除了读取内核，还要读取<code>initramfs</code>，后者会加载必要的驱动，来挂载根目录</li>
</ul>
</li>
<li>
<p>kernel + initramfs：kernel先通过<code>initramfs</code>来加载必要的驱动程序，挂载根文件系统，并加载其中的驱动程序，然后测试硬件，获取硬件信息，此时硬件已经准备就绪了</p>
<ul>
<li>kernel使用自己的检测程序测试硬件， 不一定使用BIOS检测到的信息。这意味着内核此时已经接管BIOS的工作</li>
</ul>
</li>
<li>
<p>systemd：内核调用第一个程序<code>systemd</code></p>
</li>
</ol>
<h1 id="VFS"><a class="header-anchor" href="#VFS"></a>VFS</h1>
<p>VFS（Virtual Filesystem Switch）：虚拟文件系统或虚拟文件系统转换，是Linux文件系统的虚拟化，位于内核态，将底层异构的文件系统转换为统一的文件系统，使得可以通过统一的Posix接口访问</p>
<ul>
<li>作为文件系统的抽象，VFS只存在于内存</li>
<li>VFS起源于Unix， 所以VFS适用于所有Unix like OS</li>
<li>VFS的整体组织与前文提到的VVFS相同，分为超级块、inode等</li>
</ul>
<p><img data-src="https://seec2-lyk.oss-cn-shanghai.aliyuncs.com/Hexo/OS/OS%20Basic/OS%20Persistence/VFS%20Arch.png" alt="VFS Arch"></p>
<h2 id="分层"><a class="header-anchor" href="#分层"></a>分层</h2>
<p>VFS在整个Linux系统中的分层视图如下：</p>
<p><img data-src="https://seec2-lyk.oss-cn-shanghai.aliyuncs.com/Hexo/OS/OS%20Basic/OS%20Persistence/VFS%20Layer.png" alt="VFS Layer"></p>
<p>Linux系统的User<strong>使用GLIBC（POSIX标准、GUN C运行时库）作为应用程序的运行时库</strong>，然后通过OS转换为系统调用SCI（system-call interface），SCI是操作系统内核定义的系统调用接口，这层抽象允许<strong>用户程序的I/O操作转换为内核的接口调用</strong>。VFS提供了一个抽象层，将POSIX API接口与不同存储设备的具体接口实现进行了分离，使得底层的文件系统类型、设备类型对上层应用程序透明。</p>
<h2 id="接口适配示例"><a class="header-anchor" href="#接口适配示例"></a>接口适配示例</h2>
<p>用户写入文件时，使用POSIX标准的write接口，然后陷入kernel mode，调用<code>sys_write()</code>系统调用（属于SCI层）。然后VFS层接受到该调用，转换为对给定文件系统、给定设备的操作</p>
<p><img data-src="https://seec2-lyk.oss-cn-shanghai.aliyuncs.com/Hexo/OS/OS%20Basic/OS%20Persistence/VFS%20Function%20Call%20workflow.png" alt="VFS Function Call workflow"></p>
<h2 id="跨设备-文件系统示例"><a class="header-anchor" href="#跨设备-文件系统示例"></a>跨设备/文件系统示例</h2>
<p>下面中，用户通过cp命令进行文件拷贝，用户不需要关心底层文件系统的实现，只需要通过VFS抽象层实现对不同文件系统的读写操作：</p>
<p><img data-src="https://seec2-lyk.oss-cn-shanghai.aliyuncs.com/Hexo/OS/OS%20Basic/OS%20Persistence/VFS%20example.png" alt="VFS example"></p>
<h2 id="VFS支持的系统调用"><a class="header-anchor" href="#VFS支持的系统调用"></a>VFS支持的系统调用</h2>
<p>上述示例中提到VFS也有自己的文件模型，用来支持操作系统的系统调用。下面是VFS抽象模型支持的所有Linux系统调用：</p>
<ul>
<li>文件系统相关：mount, umount, umount2, sysfs,  statfs,  fstatfs,  fstatfs64, ustat</li>
<li>目录相关：chroot，pivot_root，chdir，fchdir，getcwd，mkdir，rmdir，getdents，getdents64，readdir，link，unlink，rename，lookup_dcookie</li>
<li>链接相关：readlink，symlink</li>
<li>文件相关：chown， fchown，lchown，chown16，fchown16，lchown16，hmod，fchmod，utime，stat，fstat，lstat，acess，oldstat，oldfstat，oldlstat，stat64，lstat64，lstat64，open，close，creat，umask，dup，dup2，fcntl， fcntl64，select，poll，truncate，ftruncate，truncate64，ftruncate64，lseek，llseek，read，write，readv，writev，sendfile，sendfile64，readahead</li>
</ul>
<h2 id="VFS支持的文件系统"><a class="header-anchor" href="#VFS支持的文件系统"></a>VFS支持的文件系统</h2>
<ul>
<li>Disk-based 文件系统：Ext2, ext3, ReiserFS，Sysv, UFS, MINIX, VxFS，VFAT, NTFS，ISO9660 CD-ROM, UDF DVD，HPFS, HFS, AFFS, ADFS,</li>
<li>Network 文件系统：NFS, Coda, AFS, CIFS, NCP</li>
<li>特殊文件系统：/proc，/tmpfs等</li>
</ul>
<h1 id="Linux目录结构"><a class="header-anchor" href="#Linux目录结构"></a>Linux目录结构</h1>
<ul>
<li><code>/bin</code>:系统的二进制文件，比如各种命令</li>
<li><code>/boot</code>： 包含了启动所需的文件，如boot loader</li>
<li><code>/dev</code>:  设备对应的虚拟文件</li>
<li><code>/etc</code>: 系统和软件的配置文件</li>
<li><code>/lib</code>： 必要的共享库文件和内核模块</li>
<li><code>/media</code>: 外部设备通用挂载点的父目录</li>
<li><code>/mnt</code>: 临时文件系统的挂载点的父目录</li>
<li><code>/opt</code>：额外的软件包安装目录</li>
<li><code>/sbin</code>:只有管理员可以使用的命令的二进制文件，是与系统相关的命令，如<code>reboot</code>,<code>shutdown</code>等</li>
<li><code>/srv</code>: 系统提供的有关服务的数据</li>
<li><code>/usr</code>: Unix System Resources, 用于存放共享、只读的数据，子目录包括<code>/bin</code>, <code>/etc</code>, <code>/lib</code>, <code>/tmp</code>等，与根目录下的同名目录相比，<code>/usr</code>下的目录的数据是用于用户安装的软件的，而不是系统自带的。 还有<code>/include</code>, <code>/src</code>等目录，存放系统编程所需的头文件和源码等</li>
<li><code>/home</code>: 用户的家目录的父目录</li>
<li><code>/root</code>: root用户的家目录</li>
</ul>
<h1 id="包管理工具"><a class="header-anchor" href="#包管理工具"></a>包管理工具</h1>
<p>以<code>apt-get</code>为例，Ubuntu采用集中式软件仓库，<code>apt</code>从<code>/etc/apt/sources.list</code>中找到镜像站点地址, 从<code>package.gz</code>中获取所有包信息。 <code>apt</code>在本地存有一份软件包的信息索引，可以检测软件列表和软件依赖</p>
<p>apt在安装时安装软件和相应依赖</p>
<h1 id="File-System"><a class="header-anchor" href="#File-System"></a>File System</h1>
<h2 id="Windows"><a class="header-anchor" href="#Windows"></a>Windows</h2>
<p>普通磁盘：</p>
<ul>
<li>
<p>NTFS</p>
</li>
<li>
<p>比NTFS更早：fat32（磁盘最大32G,单个文件最大4G）, fat16</p>
</li>
</ul>
<p>U盘：exfat</p>
<h2 id="Linux"><a class="header-anchor" href="#Linux"></a>Linux</h2>
<p>ext1,2,3,4</p>
<p>如果不指定挂载，那么子目录就在父目录所在的分区上</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/16/Machine-Learning-Intro/" rel="prev" title="Machine Learning Intro">
                  <i class="fa fa-chevron-left"></i> Machine Learning Intro
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/19/Unix-Toolkit/" rel="next" title="Unix Toolkit">
                  Unix Toolkit <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">有多远滚多远</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
