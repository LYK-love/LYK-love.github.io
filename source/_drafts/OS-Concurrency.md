

# 多处理器编程

Current：exsiting, happening, or done at the *same* time. 程序的不同部分可以按不同顺序执行，且最终得到正确的结果

## 多任务OS的并发

（假设系统只有一个CPU）

OS可以同时加载多个进程

* 每个进程都有独立的进程，互不干扰
  * 即使是root权限的进程，也不能直接访问操作系统内核的内存

* 每隔一段时间，就切换到另一个进程

----

* 并发性的来源： **进程会调用OS的API**
  * `write（fd,buf,11 TiB）`（ TiB宏）
  *  `write`的实现是OS的一部分
    * `x86-64`应用程序执行`syscall`后就进入OS执行
      * 类似中断处理程序
    * 此时OS允许`write`到以南的时候，让另一个进程执行
      * 另一个进程执行了`read(fd,buf,512 MiB)`读取同一文件
      * **OS代码并发了**： OS API实现需要考虑并发
        * 虽然进程在地址空间中是独立的，但是OS中的对象是被进程共享的

## 典型的并发系统

* 并发： 多个执行流可以不按照一个特定的顺序执行
* 并行：允许多个执行流真正地同时执行
  * 需要多个处理器

| 处理器数量 | 共享内存？ | 典型的并发OS                 | 并发？并行？ |
| ---------- | ---------- | ---------------------------- | ------------ |
| 单         | 共享内存   | OS内核/多线程程序            | 并发不并行   |
| 多         | 共享内存   | OS内核/多线程程序/GPU Kernel | 并发、并行   |
| 多         | 不共享内存 | 分布式系统（消息通信）       | 并发、并行   |
|            |            |                              |              |

## 线程

线程： A single process can contain multiple threads, all of  which  are  executing  the same  program.   These  threads **share** the same global memory (data and heap segments), but each thread has its own stack (automatic variables).

多个执行流并发/并行执行，且**共享内存**

* 两个执行流共享代码和所有全局变量（数据区、堆区）
  * i.e. C++中，数据区就是全局/静态区
* 线程间指令的执行顺序是不确定（*non-deterministic*）的

* 共享：共享代码区(当前进程的代码)、数据区和堆，但不共享寄存器和栈

### POSIX Threads

POSIX为我们提供了线程库（pthreads）

* 使用`pthread_create` 创建并运行线程
* 使用`pthread_join` 等待某个线程结束
* `man 1 pthreads`

## 多处理器编程的困难

* 原子性： 即使是`i++`，也会被分成几个指令
* 顺序性：**代码**的编译器优化
* 可见性： **CPU**可以不按顺序执行指令。没有前后依赖就会被优化（并行执行）

# 并发程序的执行：状态机视角

## 程序 = 有限状态机 = 有向图

图论是理解程序的重要工具

不确定(non-deterministic)的指令可能有多个状态

* 获取处理器的”时间戳“用于精确定时
  * `rdtsc/rdtscp`

* 机器提供的”真“随机数
  * `rdrand`
* `syscall`
  * 一般用于唯一不确定性的来源
  * `read`

## 状态机模型：应用

* 在硬件上的应用： 高性能处理器实现
  * 超标量处理器
    * 同一时间执行多条指令

### Time - Travel Debugging

* 程序执行随时间渐进：$s_0 \rarr s_1 \rarr \dots$​
* 记录所有$s_i$的开销太大（$s_i$​由内存和寄存器组成）
* **记录初始状态，和每条指令前后状态的diff**

* `si/rsi`

### Record & Replay

确定的程序不需要任何记录，只需要再执行一次

* 只需记录non-deterministic指令的**效果**（side-effect），就可实现重放

* Jacking
  * 把阻塞式`syscall`改造成非阻塞式的
  * 当线程陷入`syscall`时,执行`Jacking` 程序
  * 由`Jacking` 程序来检查资源使用情况，以决定是否**执行进程**或**传递控制权给另一个进程**

* 用户级线程ULT
* 用户控件运行的线程库，提供多线程应用程序的开发和运行支撑环境
* 任何应用程序均需通过线程库进行程序设计，再与线程库连接后运行
* 线程管理的所有工作都由应用程序完成，内核完全没有意识到现成的存在

### 内核级线程的特点

* 进程中的一个线程被阻塞了，内核能调度同一进程

### 多线程实现混合式策略的特点

