---
title: Linux Account and Group
tags:
---

# user account & group

Linux 系统上面的用户如果需要登入主机以取得 shell 的环境来工作时,他需要如何进行呢? 首先,
他必须要在计算机前面利用 tty1~tty6 的终端机提供的 login 接口,并输入账号与密码后才能够登入。
如果是透过网络的话,那至少使用者就得要学习 ssh 这个功能了 (服务器篇再来谈)。 那么你输入账
号密码后,系统帮你处理了什么呢?

1. 先找寻 /etc/passwd 里面是否有你输入的账号?如果没有则跳出,如果有的话则将该账号对应的 UID 与
GID (在 /etc/group 中) 读出来,另外,该账号的家目录与 shell 设定也一并读出;
2. 再来则是核对密码表啦!这时 Linux 会进入 /etc/shadow 里面找出对应的账号与 UID,然后核对一下你刚
刚输入的密码与里头的密码是否相符?
3. 如果一切都 OK 的话,就进入 Shell 控管的阶段啰!
大致上的情况就像这样,所以当你要登入你的 Linux 主机的时候,那个 /etc/passwd 与 /etc/shadow
就必须要让系统读取啦 (这也是很多攻击者会将特殊账号写到 /etc/passwd 里头去的缘故),所以呢,
如果你要备份 Linux 的系统的账号的话,那么这两个文件就一定需要备份才行呦!



## /etc/passwd 

这个文件的构造是这样的:每一行都代表一个账号,有几行就代表有几个账号在你的系统中! 不过
需要特别留意的是,里头很多账号本来就是系统正常运作所必须要的,我们可以简称他为系统账号,
例如 bin, daemon, adm, nobody 等等,这些账号请不要随意的杀掉他呢!

我们先来看一下每个 Linux 系统都会有的第一行,就是 root 这个系统管理员那一行好了, 你可以
明显的看出来,每一行使用『:』分隔开,共有七个咚咚,分别是:
1.账号名称:
就是账号啦!用来提供给对数字不太敏感的人类使用来登入系统的!需要用来对应 UID 喔。例如 root 的
UID 对应就是 0 (第三字段);
2.密码:
早期 Unix 系统的密码就是放在这字段上!但是因为这个文件的特性是所有的程序都能够读取,这样一来
很容易造成密码数据被窃取, 因此后来就将这个字段的密码数据给他改放到 /etc/shadow 中了。所以这里你
会看到一个『 x 』
 ,呵呵!
3. UID:
  这个就是使用者标识符啰!通常 Linux 对于 UID 有几个限制需要说给您了解一下:

  | id 范围                     | 该 ID 使用者特性                                             |
  | --------------------------- | ------------------------------------------------------------ |
  | 0<br/>(系统管理员)          | 当 UID 是 0 时,代表这个账号是『系统管理员』! 所以当你要让其他的账号名称<br/>也具有 root 的权限时,将该账号的 UID 改为 0 即可。 这也就是说,一部系统上<br/>面的系统管理员不见得只有 root 喔! 不过,很不建议有多个账号的 UID 是 0<br/>啦~容易让系统管理员混乱! |
  | 1~999<br/>(系统账号)        | 保留给系统使用的 ID,其实除了 0 之外,其他的 UID 权限与特性并没有不一样。<br/>默认 1000 以下的数字让给系统作为保留账号只是一个习惯。<br/>由于系统上面启动的网络服务或背景服务希望使用较小的权限去运作,因此不希望<br/>使用 root 的身份去执行这些服务, 所以我们就得要提供这些运作中程序的拥有者<br/>账号才行。这些系统账号通常是不可登入的, 所以才会有我们在第十章提到的<br/>/sbin/nologin 这个特殊的 shell 存在。<br/>根据系统账号的由来,通常这类账号又约略被区分为两种:<br/>o<br/> 1~200:由 distributions 自行建立的系统账号;<br/>o<br/> 201~999:若用户有系统账号需求时,可以使用的账号 UID。<br/> |
  | 1000~60000<br/>(可登入账号) | 给 一 般 使 用 者 用 的。 事实 上 , 目 前 的 linux4294967295 (2^32-1) 这么大的 UID 号码喔!<br/>核心(3.10.x 版 ) 已 经 可 以支 持 到294967295 (2^32-1) |
  |                             |                                                              |
  |                             |                                                              |

  

4. 上面这样说明可以了解了吗?是的, UID 为 0 的时候,就是 root 呦!所以请特别留意一下你的
  /etc/passwd 文件!

5. GID:
  这个与 /etc/group 有关!其实 /etc/group 的观念与 /etc/passwd 差不多,只是他是用来规范组名与 GID 的
  对应而已!

6. .用户信息说明栏:
  这个字段基本上并没有什么重要用途,只是用来解释这个账号的意义而已!不过,如果您提供使用 finger 的
  功能时, 这个字段可以提供很多的讯息呢!本章后面的 chfn 指令会来解释这里的说明。

7. 家目录:
  这是用户的家目录,以上面为例, root 的家目录在 /root ,所以当 root 登入之后,就会立刻跑到 /root 目
  录里头啦!呵呵! 如果你有个账号的使用空间特别的大,你想要将该账号的家目录移动到其他的硬盘去该
  怎么作? 没有错!可以在这个字段进行修改呦!默认的用户家目录在 /home/yourIDname

8. Shell:
  我们在第十章 BASH 提到很多次,当用户登入系统后就会取得一个 Shell 来与系统的核心沟通以进行用户
  的操作任务。那为何预设 shell 会使用 bash 呢?就是在这个字段指定的啰! 这里比较需要注意的是,有
  一个 shell 可以用来替代成让账号无法取得 shell 环境的登入动作!那就是 /sbin/nologin 这个东西!这也
  可以用来制作纯 pop 邮件账号者的数据呢!

## /etc/shadow

我们知道很多程序的运作都与权限有关,而权限与 UID/GID 有关!因此各程序当然需要读取
/etc/passwd 来了解不同账号的权限。 因此 /etc/passwd 的权限需设定为 -rw-r--r-- 这样的情况, 虽
然早期的密码也有加密过,但却放置到 /etc/passwd 的第二个字段上!这样一来很容易被有心人士所
窃取的, 加密过的密码也能够透过暴力破解法去 trial and error (试误) 找出来!
因为这样的关系,所以后来发展出将密码移动到 /etc/shadow 这个文件分隔开来的技术, 而且还加
入很多的密码限制参数在 /etc/shadow 里头呢!在这里,我们先来了解一下这个文件的构造吧! 鸟
哥的 /etc/shadow 文件有点像这样:



 shadow 同样以『:』作为分隔符,如果数一数,会发现共有九个字段啊,这九个字段的用
途是这样的:
1. 账号名称:
由于密码也需要与账号对应啊~因此,这个文件的第一栏就是账号,必须要与 /etc/passwd 相同才行!
2.密码:
这个字段内的数据才是真正的密码,而且是经过编码的密码 (加密) 啦! 你只会看到有一些特殊符号的字
母就是了!需要特别留意的是,虽然这些加密过的密码很难被解出来, 但是『很难』不等于『不会』
 ,所
以,这个文件的预设权限是『-rw-------』或者是『----------』,亦即只有 root 才可以读写就是了!你得随时
注意,不要不小心更动了这个文件的权限呢!
另外,由于各种密码编码的技术不一样,因此不同的编码系统会造成这个字段的长度不相同。 举例来说,
旧式的 DES, MD5 编码系统产生的密码长度就与目前惯用的 SHA 不同(注 2)!SHA 的密码长度明显的比
2. 较长些。由于固定的编码系统产生的密码长度必须一致,因此『当你让这个字段的长度改变后,该密码就
   会失效(算不出来)』
    。 很多软件透过这个功能,在此字段前加上 ! 或 * 改变密码字段长度,就会让密码『暂
   时失效』了。
   3. 最近更动密码的日期:
   这个字段记录了『更动密码那一天』的日期,不过,很奇怪呀!在我的例子中怎么会是 16559 呢?呵呵,
   这个是因为计算 Linux 日期的时间是以 1970 年 1 月 1 日作为 1 而累加的日期,1971 年 1 月 1 日则
   为 366 啦! 得注意一下这个资料呦!上述的 16559 指的就是 2015-05-04 那一天啦!了解乎? 而想要了
   解该日期可以使用本章后面 chage 指令的帮忙!至于想要知道某个日期的累积日数, 可使用如下的程序计
   算:
   [root@study ~]# echo $(($(date --date="2015/05/04" +%s)/86400+1))
   16559
   上述指令中,2015/05/04 为你想要计算的日期,86400 为每一天的秒数, %s 为 1970/01/01 以来的累积总
   秒数。 由于 bash 仅支持整数,因此最终需要加上 1 补齐 1970/01/01 当天。
   4. 密码不可被更动的天数:(与第 3 字段相比)
   第四个字段记录了:这个账号的密码在最近一次被更改后需要经过几天才可以再被变更!如果是 0 的话,
   表示密码随时可以更动的意思。这的限制是为了怕密码被某些人一改再改而设计的!如果设定为 20 天的
   话,那么当你设定了密码之后, 20 天之内都无法改变这个密码呦!
   5. 密码需要重新变更的天数:(与第 3 字段相比)
   经常变更密码是个好习惯!为了强制要求用户变更密码,这个字段可以指定在最近一次更改密码后, 在多
   少天数内需要再次的变更密码才行。你必须要在这个天数内重新设定你的密码,否则这个账号的密码将会
   『变为过期特性』
    。 而如果像上面的 99999 (计算为 273 年) 的话,那就表示,呵呵,密码的变更没有强
   制性之意。
   6. 密码需要变更期限前的警告天数:(与第 5 字段相比)
   当账号的密码有效期限快要到的时候 (第 5 字段),系统会依据这个字段的设定,发出『警告』言论给这个
   账号,提醒他『再过 n 天你的密码就要过期了,请尽快重新设定你的密码呦!
    』,如上面的例子,则是密码
   到期之前的 7 天之内,系统会警告该用户。
   6. 密码过期后的账号宽限时间(密码失效日):(与第 5 字段相比)
   密码有效日期为『更新日期(第 3 字段)』+『重新变更日期(第 5 字段)』
    ,过了该期限后用户依旧没有更新密
   码,那该密码就算过期了。 虽然密码过期但是该账号还是可以用来进行其他工作的,包括登入系统取得
   bash 。不过如果密码过期了, 那当你登入系统时,系统会强制要求你必须要重新设定密码才能登入继续使
   用喔,这就是密码过期特性。
   那这个字段的功能是什么呢?是在密码过期几天后,如果使用者还是没有登入更改密码,那么这个账号的
   密码将会『失效』
    , 亦即该账号再也无法使用该密码登入了。要注意密码过期与密码失效并不相同。
   6. 账号失效日期:
   这个日期跟第三个字段一样,都是使用 1970 年以来的总日数设定。这个字段表示: 这个账号在此字段规
   定的日期之后,将无法再使用。 就是所谓的『账号失效』
    ,此时不论你的密码是否有过期,这个『账号』都不能再被使用! 这个字段会被使用通常应该是在『收费服务』的系统中,你可以规定一个日期让该账号不能再使用啦!

9. 保留:
最后一个字段是保留的,看以后有没有新功能加入。

## /etc/egroup

## /etc/gshadow

# Account Management

新增与移除使用者: useradd, 相关配置文件, passwd, usermod, userdel



useradd:

在 /etc/passwd 里面建立一行与账号相关的数据,包括建立 UID/GID/家目录等;
在 /etc/shadow 里面将此账号的密码相关参数填入,但是尚未有密码;
在 /etc/group 里面加入一个与账号名称一模一样的组名;
在 /home 底下建立一个与账号同名的目录作为用户家目录,且权限为 700



usermod
所谓这『人有失手,马有乱蹄』,您说是吧?所以啰,当然有的时候会『不小心手滑了一下』在 useradd
的时候加入了错误的设定数据。或者是,在使用 useradd 后,发现某些地方还可以进行细部修改。 此
时,当然我们可以直接到 /etc/passwd 或 /etc/shadow 去修改相对应字段的数据, 不过,Linux 也有
提供相关的指令让大家来进行账号相关数据的微调呢~那就是 usermod 



id 这个指令则可以查询某人或自己的相关 UID/GID 等等的信息

# ACL

//TODO

# User switch

并非所有人都能够执行 sudo , 而是仅有规范到`/etc/sudoers` 内的用户才能够执行 sudo

`/etc/soduers`:

『使用者账号』
 :系统的哪个账号可以使用 sudo 这个指令的意思;
2. 『登入者的来源主机名』
 :当这个账号由哪部主机联机到本 Linux 主机,意思是这个账号可能是由哪一部网
 络主机联机过来的, 这个设定值可以指定客户端计算机(信任的来源的意思)。默认值 root 可来自任何一部
 网络主机
3. 『(可切换的身份)』
 :这个账号可以切换成什么身份来下达后续的指令,默认 root 可以切换成任何人;
4. 『可下达的指令』
 :可用该身份下达什么指令?这个指令请务必使用绝对路径撰写。 预设 root 可以切换任
 何身份且进行任何指令之意。

 ALL 是特殊的关键词,代表任何身份、主机或指令的意思



## 特殊的 shell, /sbin/nologin

在本章一开头的 passwd 文件结构里面我们就谈过系统账号这玩意儿,这玩意儿的 shell 就是使用
/sbin/nologin ,重点在于系统账号是不需要登入的!所以我们就给他这个无法登入的合法 shell。 使
用了这个 shell 的用户即使有了密码,你想要登入时他也无法登入,因为会出现如下的讯息喔:
This account is currently not available.
我们所谓的『无法登入』指的仅是:『这个使用者无法使用 bash 或其他 shell 来登入系统』而已,
并不是说这个账号就无法使用其他的系统资源喔! 举例来说,各个系统账号,打印作业由 lp 这个
账号在管理, WWW 服务由 apache 这个账号在管理, 他们都可以进行系统程序的工作,但是『就
是无法登入主机取得互动的 shell』而已啦!^_^
换个角度来想,如果我的 Linux 主机提供的是邮件服务,所以说,在这部 Linux 主机上面的账号,
其实大部分都是用来收受主机的信件而已,并不需要登入主机的呢! 这个时候,我们就可以考虑让
单纯使用 mail 的账号以 /sbin/nologin 做为他们的 shell , 这样,最起码当我的主机被尝试想要登
入系统以取得 shell 环境时,可以拒绝该账号呢!
另外,如果我想要让某个具有 /sbin/nologin 的使用者知道,他们不能登入主机时, 其实我可以建立
『/etc/nologin.txt 』这个文件, 并且在这个文件内说明不能登入的原因,那么下次当这个用户想要登
入系统时, 屏幕上出现的就会是 /etc/nologin.txt 这个文件的内容,而不是预设的内容了!
