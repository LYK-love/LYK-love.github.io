---
title: Code Design
tags: Software Engineering
categories: Computer Science
date: 2021-06-17 15:41:09
---



Outline:

* 设计易读的代码
* 设计易维护的代码
* 设计可靠的代码
* 使用模型辅助设计复杂代码
* 单元测试用例
* 代码复杂度度量

<!--more-->

# 设计易读的代码

* 维护的需要
* 团队协作的需要

## 代码规范

### 格式

### 命名

* **临时变量命名要符合常规**。 像for循环计数器、键盘输入字符等临时变量一般不要求使用有意义的名称,但是要使用符合常规的名称,例如使用`i`、`j`命名整数而不是字符,使用`c`、`s`命名字符而不是整数。
* **不要使用太长的名称**,不利于拼写和记忆。
* **不要使用易混字符进行命名**,常见的易混字符例如“`I`”(大写i)、 “`1`”(数字1)与“`l`”(小写L)、`0`(数字零)与`o` (字母)等。使用易混字符的命名例
  如`D0Calc`与`DOCalc`。
* **不要仅仅使用不易区分的多个名称**,例如`Sales`与`Sale` , `SalesLineltem`与`SalesLineitem`。
* **不要使用没有任何逻辑的字母缩写进行命名**,例如`wrttn`、` wtht`、 `vwls`、`smch`......

### 注释

* 注释类型(ava)
  * 语句注释( `//`)
  * 标准注释(`/* */`)
  * 文档注释(`/** */`)
* 文档注释的内容
  * 包的总结和概述,每个包都要有概述;类和接口的描述,每个类和接口都要有概述;
  * 类方法的描述,每个方法都要有功能概述,都要定义完整的接口描述;
  * 字段的描述,重要字段含义、用法与约束的描
    述。
* `Javadoc`
  * 在描述方法时, Javadoc常用的标签是:
  * `@param`参数及其意义
  * `@return`返回值
  * `@throws`异常类及抛出条件
  * `@see`:引用
  * `@since `:最早使用该方法/类/接口的JDK版本)
  * `@deprecated` 引起不推荐使用的警告
* 内部注释
  * 注释要有意义，不要简单重复代码的含义
  * 重视对数据类型的注释
  * 重视对复杂控制结构的注释

# 设计易维护的代码

## 小型任务

* 要让程序代码可修改,就要控制代码的复杂度。这首先要求每个函数或方法的代码应该是内聚的,恰好完成一个功能与目标。
* 如果内聚的代码本身比较简单，复杂性可控,那么它就具有比较好的可维护性。反之,内聚的代码也可以比较复杂,典型表现是完成一-个功能需要多个步骤、代码比较长,那么就需要将其进一步分解为多个高内聚、 低耦合的小型任务。

## 复杂决策

* 使用新的布尔变量简化复杂决策
* 使用有意义的名称封装复杂决策
* 表驱动编程

## 数据使用

* 不要将变量应用于与命名不相符的目的。例如使用变量`total`表示销售的总价,而不是临时客串for循环的计数器。
* 不要将单个变量用于多个目的。在代码的前半部分使用`total`表示销售总价,在代码后半部分不再需要‘销售总价”信
  息时再用total客串for循环的计数器也是不允许的。
* 限制全局变量的使用,如果不得不使用全局变量,就明确注释全局变量的声明和使用处。
* 不要使用突兀的数字与字符,例如15 (天)、“MALE”等,要将它们定义为常量或变量后使用。

## 明确依赖关系

* 类之间模糊的依赖关系会影响到代码的理解与修改,非常容易导致修改时产生未预期的连锁反应。

# 设计可靠的代码

## 契约式设计

### 异常方式

### 断言方式

* Java中断言语句的实现
  * 为了方便实现契约式设计, Java提供了断言语句:`assert
    ExpressionI( : Expression2) ;`:
    * `Expressionl`是一-个布尔表达式,在契约式设计中可以将其
      设置为前置条件或者后置条件;
    * `Expression2`是一个值,各种常见类型都可以;
    * 如果`Expressionl`为`true` ,断言不影响程序执行;
    * 如果`ExpressionI`为`false` ,断言抛出`AssertionError`异常,如果存在`Expression2`就使用它作为参数构造`AssertionError`。

## 防御式编程

* 防御式编程的基本思想是:在一个方法与其他方法、操作系统、硬件等外界环境交互时,不能确保**外界**都是正确的,所以要在外界发生错误时,保护方法内部不受损害。
* 常见场景
  * 输入参数是否合法?
  * 用户输入是否有效?
  * 外部文件是否存在?
  * 对其他对象的引用是否为NULL ?
  * 其他对象是否已初始化?
  * 其他对象的某个方法是否已执行?
  * 其他对象的返回值是否正确?
  * 数据库系统连接是否正常?
  * 网络连接是否正常?
  * 网络接收的信息是否有效?
  * 异常和断言都可以用来实现防御式编程,两种实现方式的差异与契约式设计的实现一样。

# 使用模型辅助设计复杂代码

## 决策表

## 伪代码

## 程序流程图

# 单元测试用例

* 为方法开发测试用例主要使用两种线索:

  * 方法的规格
    * 根据第一种线索，可以使用基于规格的测试技术开发测试用例,等价类划分和边界值分析是开发单元测试用例常用
      的黑盒测试方法。

  * 方法代码的逻辑结构。
    * 根据第二种线索,可以使用基于代码的测试技术开发测试
      用例,对关键、复杂的代码使用路径覆盖,对复杂代码使
      用分支覆盖,简单情况使用语句覆盖。

* 为类开发测试用例

  * 在复杂类中,常常有着多变的状态,每次一个方法的执行改变了类状态时,都会给其他方法带来影响,也就是说复杂类的多个方法间是互相依赖的。
  * 所以，除了测试类的每一个方法之外,还要测试类不同方法之间的互相影响情况。

# 代码复杂度度量

## 度量的意义

* 基于圈复杂度,你可以衡量一 下程序代码是否需要调整。
  [McConnell2004]认为:
* 0-5子程序可能还不错;
* 6-10得想办法简化子程序了;
* 10+把子程序的某一个部分拆分成另- -个子程序并调用它。 10个决策点的上限并不是绝对的。应该把决策点的数量当做一个警示,该警示说明某个子程序可能需要重新设计了。
* `[Chidamber 1994]`基于所拥有方法的代码复杂度定义了类的复杂度:
  * `类的加权方法= Sum( Ci) i=from I to n`
* 其中, `n`为一个类的方法数量，`Ci`是第`i`个方法的代码复杂度。

# 问题代码

