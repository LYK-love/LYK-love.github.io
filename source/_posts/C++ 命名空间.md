---
title: C++ 命名空间
categories: "Language"
tags: "C++"
date: 2021-06-19 12:00:00
---

Outline:

* 命名空间的定义
* 使用命名空间成员
* 类、命名空间与作用域
* 重载与命名空间

<!--more-->

# 命名空间的定义

* `namespace` + 命名空间名字。随后是一系列由花括号后才的声明和定义

  ```
  namespace xxx
  {
  	class Sales+data { ... };
  	namespace yyy{}
  
  
  } //无须分号
  ```

* 每个命名空间都是一个作用域

  * 命名空间中的名字可以被该空间内的其他成员直接访问，也可以被内嵌作用域中的任何单位访问
  * 空间外的代码必须明确指出所用的名字属于哪个命名空间

* 命名空间可以不连续

  ```
  namespace nsp
  {
   ...
  } // 如果nsp已存在，这个定义会打开已存在的命名空间并为其添加新的声明
  ```

* 通常不把`#include`放在命名空间内部

  * 否则就会把头文件中所有的名字定义成该空间的成员

* 全局命名空间是隐式的，作用域运算符可以作用于全局作用域的成员，但是没用

  ```
  ::member_name
  ```

* **内联命名空间**： 其中的名字可以被外层命名空间直接使用

  * `inline`必须写在命名空间第一次定义的地方，后续地方可以不写

  ```C++
  inline namespace FifthEd
  {
  	...
  }
  ```

* 未命名的命名空间（  unnamed namespace ）：其中的变量拥有静态生命周期。

  * 未命名的命名空间可以在给定文件内部连续，但不能跨文件。 如果一个头文件包含了未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同实体
  * 未命名的命名空间中的名字可直接使用，也不能对其使用作用域运算符
  * 未命名的命名空间中的名字的作用域与该命名空间所在的作用域相同。这意味着如果未命名的命名空间定义在文件的最外层作用域中，则该命名空间中的名字一定要与全局作用域中的名字有区别

  ```C++
  int i;
  namesapce{
  int i; //二义性
  }
  ```

* 别名：`namespace primer = cpluscplus_primer;`
  * 不能再命名空间名字还没定义时就定义别名
* `using`声明：一次只引入命名空间的一个成员。作用域从其声明的地方开始，一直到`using`声明所在的作用域结束为止
* `using`指示：`using namespace xxx;`所有名字都可见

* 头文件如果在其顶层作用域中含有`using`指示和 `using`声明，则会将名字注入到所有包含了该文件的头文件中

# 使用命名空间成员





# 类、命名空间与作用域

# 重载与命名空间

