---
title: 设计模式
date: 2021-05-27 14:08:15
categories: Software Engineering
tags: 设计模式

---

# 可修改性

* （M）实现的可修改性
  * 对已有实现的修改
  * 例如： 修改现有促销策略
* （E）实现的可扩展性
  * 对新的实现的扩展
  * 例如： 增加一条新的促销策略
* （C） 实现的灵活性
  * 对实现的动态配置
  * 例如： 动态修改更改某商品对应促销策略

<!--more-->

## 如何实现可修改性？

* 接口与实现的分离

也就是**面向接口编程**

## 如何将接口与实现分离 --java视角

* 通过接口与实现该接口的类，将接口与实现相分离
* 通过子类继承父类，将父类的接口与子类的实现相分离

## 实现接口

* interface 定义了规约
* 实现class 实现了规约

```java
public class Client
{
    public static void main(String[] args)
    {
        //在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象
        //这就是java的力量!
        Interface_A a = new Class_A1();

        a.method_A();


    }


}

interface Interface_A
{
    public void method_A();
}

public class Class_A1 implements Interface_A
{
    public void method_A()
    {
        System.out.println("Class_A1's method_A()!")

    }

}
```



## 类图与依赖关系

类和类之间的关系: 泛化, 实现, 聚合, 组合 , 关联, 依赖,继承

* `Client`, `Interface_A`, 'Class_A1' 之间是什么关系?
* `Client`和 `Class_A1`之间是否存在依赖关系?

### 类和类（接口）之间的关系

[原文](https://cloud.tencent.com/developer/article/1390401#:~:text=%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E4%B8%BB%E8%A6%81%E6%9C%89,%E5%90%88%EF%BC%8C%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%AE%9E%E7%8E%B0%E3%80%82)

#### 泛化关系(Generalization）

继承表示的是类与类之间或者接口与接口之间的父子关系，在java中使用的是extends关键字。

一条带空心三角箭头的实线，从子类指向父类，或者子接口指向父接口。

 

#### 实现关系(Realization)

 实现表示的是一个类实现一个或者多个接口

i. 实现用一条带空心三角箭头的虚线表示，从类指向实现的接口



 

#### 依赖关系(Dependency)

  依赖主要体现了一种**使用**关系，两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，主要体现为依赖关系。

  依赖关系主要有3种表现形式：(以类A中使用了类B为例)

1. 类B是作为类A的方法参数
2. 类B是类A的方法中的局部变量
3. 在类A中调用类B的静态方法

```java
public class Student {
	public void read(Book book){
		System.out.println("读的书是：" + book.getName());
	}
	
	public void eat(Food food){
		System.out.println("吃的是：" + food.getName());
	}
}
```



#### 关联关系(Association)

关联主要体现的是一种对应关系，两个相对独立的对象，当一个对象的实例与另一个对象的实例存在固定的对应关系时，这两个对象之间为关联关系。通常是将一个类的对象作为另一个类的成员变量。

关联关系的分类：

1. 单向关联
2. 双向关联



![]()

(单向关联)

![]()



(双向关联)

```java
public class Student{
	private String id;
	private ClassName className;

	public Student(String id){
		this.id = id;
		this.className = new ClassName();
	}
}
```



#### 聚合关系(Aggregation)

聚合是关联关系的一种，表现了一种弱的“拥有”关系，关联关系的对象之间是相互独立的，但是聚合关系的对象之间存在着一种包容关系，体现的是A对象可以包容B对象，但是B对象不是A对象的一部分。他们之间是“整体-个体”的关系。

b) 语法：同关联关系

c) 符号：空心菱形加实线箭头  

 ```java
 public class People{
 	private Student student;
 	private Worker worker;
 	private Farmer farmer;
 
 	public People(Student student, Worker worker, Farmer farmer){
 		this.student = student;
 		this.worker = worker;
 		this.farmer = farmer;
 	}
 }
 ```



 

#### 组合关系(Composition)

组合是一种强的“拥有”关系，组合中的类之间是“整体-部分”的关系，“整体”负责“部分”的生命周期，“部分”和“整体”的生命周期是一样的，“部分”单独存在是没有任何意义的。通常在整体类的构造方法中直接实例化成员类。

b) 语法：同关联关系

c) 符号：实心菱形加实线箭头   

```java
public class Bird{
	private Wing wing;

	public People(){
		wing = new Wing();
}
```



## (M)实现的可修改性

* 对于实现的可修改性，无论是`Class_A1`还 是`Sub_A1`的`method_A`方法的实现的修改 都和`Client`中的调用代码没有任何耦合性

```java
public class Class_A2 implements Interface_A
{
    public void method_A()
    {
        System.out.println("Class_A2's method_A()!");

    }

}


public class Sub_A2 extends Super_A1
{
public void method_A()
{
    //子类的实现
    System.out.println("Sub_A2's method_A()!");
}

}
```



## (E)实现的可扩展性

* 对于实现的可扩展性，我们可以通过 `Class_A2`和`Sub_A2`的创建来实现。

```java
public class Client
{
    Interface_A A = new Class_A1();
    //Interface_A A = new Class_A1();
    //Super_A a = new Sub_A1();
    //Super_A a = new Sub_A2();

    //调用的接口不变
    //但是当a指向不同的类的对象，就会动态地选择不同的实现
    a.method_A();

}
```



## (C)实现的灵活性

### 继承



* "父类"定义了规约
* "子类"实现了规约

```java
public class Client
{
    public static void main(String[] args)
    {
        Super_A a = new Sub_A1();

        a.method_A();
    }
}

public class Super_A1
{
    public void method_A()
    {
        //父类的接口和实现
        System.out.println("Super_A's method_A()!");
    }

}

public class Sub_A1 extends Super_A1
{
	public void method_A()
	{
    	//子类的实现
    	System.out.println("Sub_A's method_A()!");
	}
}
```

#### 继承的优点

* 虽然继承也能很好的完成接口与实现的分 离，但是继承还有它独有的特征。
* 子类不但继承了父类的接口还继承了父类 的实现，这可以更好的进行代码的重用

#### 继承的缺点

* 继承的父类与所有子类存在共有接口的耦 合性。当父类接口发生改变的时候，子类 的接口就一定会更改，这样就会影响到 Client代码。
* 而且当子类创建对象的时候，就决定了其 实现的选择，没法再动态的修改

### 组合

* 而利用接口的组成关系 ，却能在实现接口和实 现的前提下，体现更好 的灵活性。前端类和后 端类是组合关系。前段 类重用了后端类的代码 。

```java
class Backend
{
    public int method_2()
    {}
}

class Frontend
{
    public Backend back = new Backend();
    public int method_2(){
        back.emthod_2();
    }
}

class Client
{
    public static void main(String[] args)
    {
        Frontend front = new Frontend();
        int i = front.method_2();
        
    }
}
```

#### 组合的优点

* 前端和后端在接口上不存在耦合性。当后 端接口发送改变的时候，并不会直接影响 到Client代码。
* 后端类的实现亦可以动态创建、动态配置 、动态销毁，非常灵活。

# 设计模式

* Designing OO software is hard 
* Designing reusable OO software – harder 
* Experienced OO designers make good design 
* New designers tend to fall back on non-OO techniques used before
* Experienced designers know something – what is it?
* Expert designers know not to solve every problem from first principles
* They reuse solutions 
* These patterns make OO designs more flexible, elegant, and ultimately reusable



**"不要造轮子"**



* 组成与协作： 
  * 描述了设计中涉及的各个类的组成成分，他们之间的相互关系及各自 的职责和协作方式。
  * 应用场景： 
    * 描述了应该何时使用模式。它解释了设计模式所要解决的问题，以及解决这个问题时所面临的特点的环境、限制条件、场景等。这也是我 们在应用某种模式之前，需要仔细去体察的。
  * 使用注意点：
    * 因为模式只是一个模板，他可以应用与多种不同场合，所以解决方案 并不描述一个具体的实现，而是提供解决方案的一个抽象模型

# 策略模式

## 典型问题

* 在一个大规模的连锁超市中雇员的薪水支付可以分为很多 种。其中雇员的薪酬支付方式和支付频率就有好几种：
  * 有些雇员是钟点工，按时薪来支付。薪水=时薪*工作 小时数。每周三支付*
  * *有些雇员按月薪支付。薪水=固定月薪。每月21日支付 
  * 有些雇员是提成制。薪水=销售额*提成比率。每隔一 周的周三支付

学艺不精的小伙伴可能上来就是`if-else`, 太丑陋啦`(*>﹏<*)′

### 潜在的变化

* 钟点工可能两星期支付一次； 
  * (M)实现的可修改性
* 现在是时薪以后可能会变为月薪； 
  * (C)实现的灵活性
* 也有可能出现新的薪水支付方式和支付频率。 
  * (E)实现的可扩展性

### 设计分析 -1

* 支付设计几个类？
* 各自有几个职责？

首先，可以把上下文和策略分割为不同的类 实现不同的职责。上下文`Context`类负责通过 执行策略实现自己职责；而策略类`Strategy`只负责复杂策略的实现。

### 设计分析 -2

* 如何设计策略类？ 
* 接口和实现要不要分离？ 
* 如果要，如何分离？

### 组合还是继承?

* 其次，上下文类和策略类之间的关系是用组合比继承更加合 适。 
  * 组合使得上下文类和策略类之间的接口之间的耦合性会很低；
  * 策略类的接口和实现的修改都相对比较容易；
  * 此外，如果是继承关系，则上下文类只能在行为的n种实 现里面n选一（对象创建时就选定了策略），而如果是组 合关系，上下文类则可以维护一个策略队列，实现n选多 ，从而达到动态的配置。

* 最后，各种策略则在具体策略类（ConcreteStrategy） 中提供，而**向上下文类提供统一的策略接口**
  * 由于**策略和上下文独立开来**，策略的增减、策略实现的修改都不会影响上下文和使用上下文的客户。
  * 当出现新的促销策略或现有的促销策略发生变化 时，只需要实现新的具体策略类（实现策略的接口),由客户使用。

| 使用的设计原则 | 解释                                            |
| -------------- | ----------------------------------------------- |
| 减少耦合       | 减少策略的使用类和策略的实现类的直接耦合        |
| IoC            | 策略的使用类依赖的是策略的接口,而非策略的实现类 |



策略模式：定义了算法族，分别封装起来， 让他们之间可以互相替换，此模式让算法的 变化独立于使用算法的客户

## 参与者

* 上下文（Contex）: 1)被配置了具体策略 ConcreteStrategy； 2)拥有Strategy对象的一个引用； 3)实现了一些方法以供Strategy访问其数据。
* 策略（Strategy）: 声明了所支持策略的接口。 Context利用这些被ConcreteStrategy定义的接口。
* 具体策略（ConcreteStrategy）: 实现了Strategy声明 的接口，给出了具体的实现。

## 协作

* 上下文`Context`和`Strategy`的相互协作完成整个算法。 `Context`可能会通过提供方法让`Strategy`访问其数据；甚 至将自身的引用传给`Strategy`，供其访问其数据。 `Strategy`会在需要的时候访问`Context`的成员变量。
* 上下文`Context`将一些对他的请求转发给策略类来实现 ，客户（`Client`）通常创建`ConcreteStrategy`的对象，然 后传递给C`ontext`来灵活配置`Strategy`接口的具体实现； 这样`Client`就有可以拥有一个`Strategy`接口的策略族，其 中包含多种`ConcreteStrategy`的实现。

## 应用场景

* 当很多相关类只在它们的行为的实现上不一样。策略模式提供了一个很好的方式来配置某个类，让其具有上述多种实现之一。
* 当我们需要同一个行为的不同实现（变体）的时候。策略模式可以用作实现这些变体。
* 算法需要用到一些数据，而这些数据不应该被客户知道。我们可以通过策略模式隐藏复杂的算法和数据接口。
*  一个类定义了很多行为，这些行为作为一个`switch`选择语句的分支执行部分。策略模式可以消除这些分支选择

## 注意点

* `Strategy`可以是接口，也可以是类。如果是类，则可以抽象所有具体算法中公共的实现部分。
* 当然，我们也可以直接通过Context的子类来实现不同的 Context实现。不过这样算法的具体实现，就和算法的利用的 实现项目交织在一起，不利于理解和维护.
* 策略模式消除了类似根据策略类型的Switch语句。 
* 可以动态选择不同的策略 • 客户必须提前知晓各自不同的策略。 
* Context和Strategy之间的通讯是有代价的。Context提供了对 其成员变量的访问方式。可以有时候，对于某些具体的策略 的实现ConcreteStrategy可能并不需要全部的访问，这会存在一定的隐患。
* 策略模式会创建出较多的对象。

# 抽象工厂模式

策略模式解决的是**行为问题**, 工厂模式解决**对象创建问题**

## 工厂模式

工厂
模式就是为对象的创建提 供一个接口，将具体创建 的实现封装在接口之下， 这样具体创建的实现的改 变就不会对客户代码`Client`类产生影响。从而 降低了Client类和多个具体产品类的耦合。
